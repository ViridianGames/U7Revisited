#!/bin/bash
# Main wrapper script for U7Revisited development tasks

# --- Colors ---
CLR_RST="\e[0m" # Reset
CLR_RED="\e[31m" # Error
CLR_GRN="\e[32m" # Success
CLR_YLW="\e[33m" # Warning
CLR_BLU="\e[34m" # Info / Headers
CLR_CYN="\e[36m" # Info / Prompt

SCRIPT_DIR="$(cd "$(dirname "${BASH_SOURCE[0]}")" &> /dev/null && pwd)"
SCRIPTS_SUBDIR="scripts" # Directory where other scripts reside

# --- Helper Functions ---
print_header() {
    echo ""
    echo -e "${CLR_BLU}==================================================${CLR_RST}"
    printf "  ${CLR_BLU}U7Revisited Task: %s${CLR_RST}\n" "$1"
    echo -e "${CLR_BLU}==================================================${CLR_RST}"
}

print_footer() {
    echo -e "${CLR_BLU}==================================================${CLR_RST}"
    echo -e "  ${CLR_GRN}Task Finished${CLR_RST}"
    echo -e "${CLR_BLU}==================================================${CLR_RST}"
    echo ""
}

print_error() {
    echo -e "${CLR_RED}[U7 ERROR] $1${CLR_RST}" >&2
}

# Simple spinner function
spinner() {
    local pid=$1
    local delay=0.1
    local spinstr='|/-\'
    # Hide cursor
    tput civis
    # Ensure cleanup on exit/interrupt
    trap 'tput cnorm; exit' INT TERM EXIT

    while ps -p $pid > /dev/null; do
        local temp=${spinstr#?}
        # Use \r to return to beginning of line and overwrite
        printf "\r${CLR_BLU}[U7Revisited] Working.. [%c]${CLR_RST}" "$spinstr"
        local spinstr=$temp${spinstr%"$temp"}
        sleep $delay
    done
    # Clear the spinner line after loop finishes
    # Get terminal width or default to 80, print spaces, then return cursor
    printf "\r%-${COLUMNS:-80}s\r" ""
    # Restore cursor
    tput cnorm
    # Remove the trap
    trap - INT TERM EXIT
}

# --- Check for scripts directory ---
SCRIPTS_DIR="${SCRIPT_DIR}/${SCRIPTS_SUBDIR}"
if [ ! -d "${SCRIPTS_DIR}" ]; then
    print_error "Scripts directory '${SCRIPTS_DIR}' not found!"
    exit 1
fi

# --- Default values ---
BUILD_TYPE="release" # Default to release
BUILD_ARGS=()
RUN_EXTRA_ARGS=()
DO_BUILD=false
DO_CLEAN=false
DO_CONFIGURE=false
DO_RUN=false
DO_SETUP_IDE=false
DO_FIX_REQUIRES=false # New flag

# --- Argument Parsing ---
COMMAND_GIVEN=false
while [[ $# -gt 0 ]]; do
    case "$1" in
        build)
            DO_BUILD=true
            COMMAND_GIVEN=true
            shift
            ;;
        run)
            DO_RUN=true
            COMMAND_GIVEN=true
            shift
             # Remaining args are for the game itself
            RUN_EXTRA_ARGS=("$@")
            break # Consume rest for run
            ;;
        clean)
            DO_CLEAN=true
            COMMAND_GIVEN=true
             # Allow chaining, e.g., u7 clean build
            shift
            ;;
        configure)
             DO_CONFIGURE=true
             COMMAND_GIVEN=true
             shift
            ;;
        setup)
            DO_SETUP_IDE=true
            COMMAND_GIVEN=true
            shift
            ;;
        scripts) # New command
            COMMAND_GIVEN=true
            shift # Move past 'scripts'
            if [[ "$1" == "--fix-requires" ]]; then
                 DO_FIX_REQUIRES=true
                 shift # Move past '--fix-requires'
            else
                 print_error "Unknown scripts command: '$1'. Available: --fix-requires"
                 exit 1
            fi
            ;;
        --debug) # Explicitly request debug build
            BUILD_TYPE="debug"
            shift
            ;;
        --release) # Allow explicit --release for clarity, but it's the default
            BUILD_TYPE="release"
            shift
            ;;
        -h|--help)
            echo "Usage: $0 [command...] [options...] [-- game_args...]"
            echo ""
            echo "Commands:"
            echo "  build           Build the project (default: release)."
            echo "  run             Run the project (builds first if needed, default: release)."
            echo "  clean           Clean the build directory for the selected type."
            echo "  configure       Force configure before build."
            echo "  setup           Run the IDE setup script (Linux/macOS)."
            echo "  scripts         Run utility scripts:"
            echo "    --fix-requires  Check and add missing 'require "U7LuaFuncs"' to Lua scripts."
            echo ""
            echo "Options:"
            echo "  --debug         Perform actions for the debug build type."
            echo "  --release       Perform actions for the release build type (default)."
            echo "  -h, --help      Show this help message."
            echo ""
            echo "Examples:"
            echo "  $0 build                # Build release (default)"
            echo "  $0 build --debug        # Build debug"
            echo "  $0 run                  # Build (if needed) and run release"
            echo "  $0 clean build --debug   # Clean debug, then build debug"
            echo "  $0 run -- --some-game-flag # Run release, passing flag to game"
            echo "  $0 setup                # Generate IDE config files (Linux/macOS)"
            echo "  $0 scripts --fix-requires # Check/fix Lua scripts"
            exit 0
            ;;
        --) # Separator for game args if 'run' isn't the last command
            shift
            RUN_EXTRA_ARGS=("$@")
            break
            ;;
        *) # Check if it's a valid script argument *after* a command
            if [[ "$COMMAND_GIVEN" == false ]]; then
                 print_error "Unknown command or option: $1. Commands must come before options like --debug or --release."
                 exit 1
            else
                # If a command was given, maybe this is an arg for the game?
                # Re-add it to RUN_EXTRA_ARGS if DO_RUN is the intended final action
                # This part is tricky without knowing the final action intended.
                # For simplicity, we'll error out on unknown args after a command unless it's after 'run'
                print_error "Unknown argument: $1. Did you mean to put it after '--' for the 'run' command?"
                exit 1
            fi
            ;;
    esac
done

# --- Execute Tasks ---

# Setup IDE
if [[ "$DO_SETUP_IDE" == true ]]; then
    print_header "IDE Setup (Linux/macOS)"
    SETUP_SCRIPT="${SCRIPTS_DIR}/setup_ide.sh"
    if [ -f "$SETUP_SCRIPT" ]; then
        # Use standard echo (adds newline) so spinner appears below
        echo -e "${CLR_CYN}--> Running IDE setup script...${CLR_RST}"
        # Run script in background
        bash "$SETUP_SCRIPT" &
        SETUP_PID=$!
        # Start spinner
        spinner $SETUP_PID
        # Wait for script to finish and get exit code
        wait $SETUP_PID
        SETUP_EXIT_CODE=$?

        if [ ${SETUP_EXIT_CODE} -ne 0 ]; then
             print_error "IDE setup script failed with exit code ${SETUP_EXIT_CODE}."
             exit 1
        fi
        print_footer
    else
        print_error "Setup script not found: ${SETUP_SCRIPT}"
        exit 1
    fi
fi

# Fix Lua Requires Script
if [[ "$DO_FIX_REQUIRES" == true ]]; then
    print_header "Fix Lua Requires"
    FIX_SCRIPT="${SCRIPTS_DIR}/check_lua_requires.sh"
    if [ -f "$FIX_SCRIPT" ]; then
        echo "--> Running Lua require check script..."
        bash "$FIX_SCRIPT" # Execute the script
        FIX_EXIT_CODE=$?
        # Exit code 2 from check_lua_requires.sh means user chose to restore backups
        if [ ${FIX_EXIT_CODE} -ne 0 ] && [ ${FIX_EXIT_CODE} -ne 2 ]; then
             print_error "Lua require check script failed with exit code ${FIX_EXIT_CODE}."
             # Don't exit here if the user restored (exit code 2), just report
             if [ ${FIX_EXIT_CODE} -ne 2 ]; then exit 1; fi
        elif [ ${FIX_EXIT_CODE} -eq 2 ]; then
             echo "[U7 INFO] Changes were restored from backup by user request."
        fi
        print_footer
    else
        print_error "Lua require check script not found: ${FIX_SCRIPT}"
        exit 1
    fi
fi

# Handle build dependencies (clean, configure)
if [[ "$DO_CLEAN" == true ]]; then
    BUILD_ARGS+=("--clean")
fi
if [[ "$DO_CONFIGURE" == true ]]; then
     BUILD_ARGS+=("--configure")
fi

# Add --release flag specifically for build.sh if needed
if [[ "$BUILD_TYPE" == "release" ]]; then
     BUILD_ARGS+=("--release")
fi

# Build (if build cmd or run cmd was specified, and not only setup or scripts)
BUILD_NEEDED=$( [[ "$DO_BUILD" == true || "$DO_RUN" == true ]] && echo true || echo false )
BUILD_SCRIPT="${SCRIPTS_DIR}/build.sh"

# Determine if ONLY setup or fix-requires was specified
ONLY_NON_BUILD_COMMAND=$( [[ ( "$DO_SETUP_IDE" == true || "$DO_FIX_REQUIRES" == true ) && \
                             "$DO_BUILD" == false && \
                             "$DO_CLEAN" == false && \
                             "$DO_CONFIGURE" == false && \
                             "$DO_RUN" == false ]] && echo true || echo false )

# Only run build if build/run was requested AND it wasn't the case that ONLY setup/fix-requires was specified.
if [[ "$BUILD_NEEDED" == true && "$ONLY_NON_BUILD_COMMAND" == false ]]; then

    # The --release flag is added above if needed. build.sh defaults to debug if it's absent.

    print_header "Build ($BUILD_TYPE)"
    if [ -f "$BUILD_SCRIPT" ]; then
        # Use standard echo (adds newline) so spinner appears below
        echo -e "${CLR_CYN}--> Running build script: ${BUILD_SCRIPT} ${BUILD_ARGS[@]}${CLR_RST}"
        # Run script in background
        bash "$BUILD_SCRIPT" ${BUILD_ARGS[@]} &
        BUILD_PID=$!
        # Start spinner
        spinner $BUILD_PID
        # Wait for script to finish and get exit code
        wait $BUILD_PID
        BUILD_EXIT_CODE=$?

        if [ ${BUILD_EXIT_CODE} -ne 0 ]; then
             print_error "Build script failed with exit code ${BUILD_EXIT_CODE}."
             exit 1
         fi
        print_footer
    else
        print_error "Build script not found: ${BUILD_SCRIPT}"
        exit 1
    fi
fi

# Run
if [[ "$DO_RUN" == true ]]; then
    print_header "Run ($BUILD_TYPE)"
    RUN_SCRIPT="${SCRIPTS_DIR}/run_u7.sh"
    RUN_FLAGS=()
    PASS_THROUGH_ARGS=() # Arguments for run_u7.sh itself

     # Check for args meant for run_u7.sh vs the game
     # Note: RUN_EXTRA_ARGS contains everything after 'run' or '--'
     for arg in "${RUN_EXTRA_ARGS[@]}"; do
         case "$arg" in
             --healthcheck) PASS_THROUGH_ARGS+=("--healthcheck") ;;
             --verbose) PASS_THROUGH_ARGS+=("--verbose") ;;
             # Could add other run_u7 specific flags here
             *) break ;; # Stop processing run_u7 flags at first non-flag
         esac
         shift # Shift only if it was a known flag for run_u7
         RUN_EXTRA_ARGS=("${RUN_EXTRA_ARGS[@]:1}") # Update game args array (crude shift)
     done

     if [[ "$BUILD_TYPE" == "debug" ]]; then
        PASS_THROUGH_ARGS+=("--debug") # --debug is also handled by run_u7.sh
     fi
     # Append remaining args (should be game args now)
     PASS_THROUGH_ARGS+=("${RUN_EXTRA_ARGS[@]}")

    if [ -f "$RUN_SCRIPT" ]; then
         echo -e "${CLR_CYN}--> Running execution script: ${RUN_SCRIPT} ${PASS_THROUGH_ARGS[*]}${CLR_RST}"
         # Run in foreground, pass filtered args
         bash "$RUN_SCRIPT" "${PASS_THROUGH_ARGS[@]}"
         RUN_EXIT_CODE=$?
         if [ ${RUN_EXIT_CODE} -ne 0 ]; then
             echo -e "${CLR_YLW}[U7 INFO] Game process exited with code ${RUN_EXIT_CODE}.${CLR_RST}"
         fi
         print_footer
    else
         print_error "Run script not found: ${RUN_SCRIPT}"
         exit 1
    fi
fi

# If no command was given, show help implicitly.
if [[ "$COMMAND_GIVEN" == false ]]; then
    bash "$0" --help
    exit 1 # Exit with error if no command specified
fi

exit 0 